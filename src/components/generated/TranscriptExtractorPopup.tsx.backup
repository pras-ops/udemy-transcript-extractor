"use client";

import * as React from "react";
import { useState, useEffect, useMemo } from 'react';
import { FileText, Sun, Moon, Download, ChevronDown, Clock, Clipboard, Play, Lock, Github, Zap, AlertCircle, CheckCircle, Loader2 } from 'lucide-react';
import { ExtensionService } from '../../lib/extension-service';
import { StorageService } from '../../lib/storage-service';

// Simple debouncing utility
const debounce = (func: Function, wait: number) => {
  let timeout: NodeJS.Timeout;
  return (...args: any[]) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(null, args), wait);
  };
};

// Custom LogIcon component using actual Log.png image
const LogIcon = ({ className = "", ...props }: React.ImgHTMLAttributes<HTMLImageElement>) => (
  <img 
    src="/Log.png" 
    alt="Transcript Extractor Logo"
    className={className}
    {...props}
  />
);

export const TranscriptExtractorPopup = () => {
  const [isDarkMode, setIsDarkMode] = useState(true);

  const [includeTimestamps, setIncludeTimestamps] = useState(true);
  const [exportFormat, setExportFormat] = useState<'markdown' | 'txt' | 'json' | 'rag'>('markdown');
  const [exportTarget, setExportTarget] = useState<'clipboard' | 'download'>('clipboard');
  const [showFormatDropdown, setShowFormatDropdown] = useState(false);

  const [isExtracting, setIsExtracting] = useState(false);
  const [availability, setAvailability] = useState<{ platform: string; hasTranscript: boolean; isCoursePage: boolean } | null>(null);
  const [currentVideo, setCurrentVideo] = useState<{ title: string; duration: string } | null>(null);
  const [courseStructure, setCourseStructure] = useState<any>(null);
  const [isCourseStructureLoading, setIsCourseStructureLoading] = useState(false);
  const [extractedTranscript, setExtractedTranscript] = useState<string>('');
  const [extractionStatus, setExtractionStatus] = useState<'idle' | 'extracting' | 'success' | 'error'>('idle');
  const [errorMessage, setErrorMessage] = useState<string>('');
  // Test state variables removed for production
  
  // Batch collection states
  const [batchMode, setBatchMode] = useState<'next' | 'collect'>('next');
  const [batchProgress, setBatchProgress] = useState<{[lectureId: string]: 'pending' | 'collecting' | 'completed' | 'failed' | 'skipped'}>({});
  const [isBatchCollecting, setIsBatchCollecting] = useState(false);
  const [batchStats, setBatchStats] = useState({ total: 0, completed: 0, failed: 0, skipped: 0 });
  const [isNavigating, setIsNavigating] = useState(false);
  const [currentProcessingLecture, setCurrentProcessingLecture] = useState<string>('');
  const [currentSection, setCurrentSection] = useState<string>('');
  const [progressUpdateTrigger, setProgressUpdateTrigger] = useState(0);
  const [clipboardEntries, setClipboardEntries] = useState(0);
  const [clipboardData, setClipboardData] = useState<string>('');
  
  // AI Summarization states
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [summaryResult, setSummaryResult] = useState<{
    summary: string;
    keyPoints?: string[];
    wordCount: number;
    processingTime: number;
    modelUsed: string;
  } | null>(null);
  const [summaryOptions, setSummaryOptions] = useState({
    style: 'bullet' as 'bullet' | 'paragraph' | 'detailed',
    includeKeyPoints: true
  });
  const [isWebLLMSupported, setIsWebLLMSupported] = useState<boolean | null>(null);
  const [diagnosticsResult, setDiagnosticsResult] = useState<any>(null);
  
  // Tab state
  const [activeTab, setActiveTab] = useState<'transcript' | 'ai' | 'tracking'>('transcript');
  
  // Export state
  const [isExporting, setIsExporting] = useState(false);
  
  // AI Summary tracking state
  const [aiSummaries, setAiSummaries] = useState<AISummary[]>([]);
  const [isLoadingSummaries, setIsLoadingSummaries] = useState(false);
  
  const handleThemeToggle = () => {
    setIsDarkMode(!isDarkMode);
    if (!isDarkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  };

  // Calculate progress percentage using useMemo for better performance
  const progressPercentage = useMemo(() => {
    const totalProcessed = batchStats.completed + batchStats.failed + batchStats.skipped;
    if (batchStats.total === 0) {
      // Dynamic counting mode - show progress based on completed count
      return totalProcessed > 0 ? Math.min((totalProcessed / (totalProcessed + 1)) * 100, 100) : 0;
    }
    // Fixed total mode - show progress as percentage of total
    const percentage = (totalProcessed / batchStats.total) * 100;
    return Math.min(percentage, 100); // Cap at 100%
  }, [batchStats, progressUpdateTrigger]);

  // Get current section number from URL or video info
  const getCurrentSectionNumber = (): number => {
    try {
      // Try to extract section from URL first
      const urlMatch = window.location.href.match(/lecture\/(\d+)/);
      if (urlMatch) {
        const lectureId = parseInt(urlMatch[1]);
        // Map lecture ID to approximate section (this is a rough estimate)
        // You can adjust this mapping based on your course structure
        return Math.floor(lectureId / 100) + 1;
      }
      
      // Fallback: try to get from video title
      if (currentVideo?.title) {
        const sectionMatch = currentVideo.title.match(/Section (\d+)/i);
        if (sectionMatch) {
          return parseInt(sectionMatch[1]);
        }
      }
      
      // Default to 1 if we can't determine
      return 1;
    } catch (error) {
      return 1;
    }
  };

  // Simple section counter - show current section only
  const getSectionCounter = (): string => {
    const currentSection = getCurrentSectionNumber();
    if (batchStats.total === 0) {
      // Dynamic counting mode
      return `${currentSection}/âˆž`;
    }
    return `${currentSection}/${batchStats.total}`;
  };



  // Check availability when component mounts and load saved state
  useEffect(() => {
    console.log('ðŸŽ¯ Transcript Extractor Popup initialized - v3.0.3 with AI debugging');
    console.log('ðŸŽ¯ Popup loaded successfully - buttons should work now!');
    console.log('ðŸŽ¯ NEW VERSION 3.0.3 LOADED - If you see this, popup is working!');
    
    // Force alert to test if popup is working
    setTimeout(() => {
      alert('POPUP v3.0.3 LOADED - If you see this, the popup is working!');
    }, 1000);
    
    // Apply dark mode by default
    document.documentElement.classList.add('dark');
    
    loadSavedState();
    checkPageAvailability();
    
    // Load clipboard data from storage
    const loadClipboardData = async () => {
      try {
        const { clipboardData: savedData, clipboardEntries: savedEntries } = await StorageService.loadClipboardData();
        setClipboardData(savedData);
        setClipboardEntries(savedEntries);
        // Loaded clipboard data from storage
      } catch (error) {
        console.error('Failed to load clipboard data:', error);
      }
    };
    
    loadClipboardData();
    
    // Don't auto-clear data when opening popup on non-supported tabs
    // Data will only be cleared when tabs are actually closed
    
    // Check WebLLM support
    checkWebLLMSupport();
    
    // Load AI summaries
    loadAiSummaries();
    
    // Simple cleanup on unmount
    return () => {
      setExtractionStatus('idle');
      setExtractedTranscript('');
    };
  }, []);

  // Check if WebLLM is supported with comprehensive diagnostics
  const checkWebLLMSupport = async () => {
    console.log('ðŸ¤– Checking WebLLM support...');
    try {
      console.log('ðŸ¤– Importing WebLLM service...');
      const { WebLLMService } = await import('../../lib/webllm-service');
      console.log('ðŸ¤– WebLLM service imported successfully');
      
      // Run comprehensive diagnostics
      const diagnostics = await runComprehensiveDiagnostics();
      console.log('ðŸ¤– Comprehensive diagnostics:', diagnostics);
      
      const isSupported = WebLLMService.isSupported() && diagnostics.webgpu.available;
      console.log('ðŸ¤– WebLLM support check result:', isSupported);

      setIsWebLLMSupported(isSupported);
      setDiagnosticsResult(diagnostics);
    } catch (error) {
      console.error('ðŸ¤– Failed to check WebLLM support:', error);
      setIsWebLLMSupported(false);
      setDiagnosticsResult(null);
    }
  };

  // Comprehensive diagnostics function
  const runComprehensiveDiagnostics = async () => {
    const diagnostics = {
      timestamp: new Date().toISOString(),
      browser: {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        cookieEnabled: navigator.cookieEnabled,
        onLine: navigator.onLine
      },
      webgpu: {
        available: false,
        adapter: null as any,
        error: null as string | null
      },
      webassembly: {
        available: !!WebAssembly,
        version: WebAssembly ? '1.0' : 'Not available'
      },
      memory: {
        deviceMemory: (navigator as any).deviceMemory || 'Unknown',
        hardwareConcurrency: navigator.hardwareConcurrency || 'Unknown'
      },
      webgl: {
        version1: false,
        version2: false,
        renderer: null as string | null
      },
      storage: {
        localStorage: false,
        sessionStorage: false,
        indexedDB: false
      },
      network: {
        connection: (navigator as any).connection ? {
          effectiveType: (navigator as any).connection.effectiveType,
          downlink: (navigator as any).connection.downlink
        } : 'Unknown'
      }
    };

    // Check WebGPU
    try {
      diagnostics.webgpu.available = !!(navigator as any).gpu;
      if (diagnostics.webgpu.available) {
        const adapter = await (navigator as any).gpu.requestAdapter();
        diagnostics.webgpu.adapter = adapter ? {
          info: adapter.info || 'Available but no info',
          limits: adapter.limits || 'No limits info'
        } : null;
      }
    } catch (error) {
      diagnostics.webgpu.error = (error as Error).message;
      console.warn('ðŸ¤– WebGPU check failed:', error);
    }

    // Check WebGL
    try {
      const canvas = document.createElement('canvas');
      const gl1 = canvas.getContext('webgl');
      const gl2 = canvas.getContext('webgl2');
      
      diagnostics.webgl.version1 = !!gl1;
      diagnostics.webgl.version2 = !!gl2;
      
      if (gl2) {
        const debugInfo = gl2.getExtension('WEBGL_debug_renderer_info');
        if (debugInfo) {
          diagnostics.webgl.renderer = gl2.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
        }
      }
    } catch (error) {
      console.warn('ðŸ¤– WebGL check failed:', error);
    }

    // Check storage APIs
    try {
      diagnostics.storage.localStorage = !!window.localStorage;
      diagnostics.storage.sessionStorage = !!window.sessionStorage;
      diagnostics.storage.indexedDB = !!window.indexedDB;
    } catch (error) {
      console.warn('ðŸ¤– Storage check failed:', error);
    }

    return diagnostics;
  };

  // Diagnostic function to test AI summarization
  const runAIDiagnostics = async () => {
    console.log('ðŸ¤– Running AI diagnostics...');
    setErrorMessage('');
    
    try {
      // Step 1: Run comprehensive diagnostics
      console.log('ðŸ¤– Step 1: Running comprehensive diagnostics...');
      const diagnostics = await runComprehensiveDiagnostics();
      console.log('ðŸ¤– Comprehensive diagnostics:', diagnostics);
      
      // Check each requirement
      const checks = {
        webgpu: diagnostics.webgpu.available,
        webassembly: diagnostics.webassembly.available,
        webgl: diagnostics.webgl.version2,
        storage: diagnostics.storage.localStorage && diagnostics.storage.indexedDB,
        memory: diagnostics.memory.deviceMemory === 'Unknown' || parseInt(diagnostics.memory.deviceMemory) >= 4
      };
      
      console.log('ðŸ¤– System checks:', checks);
      
      // Show detailed results
      const failedChecks = Object.entries(checks).filter(([key, passed]) => !passed);
      if (failedChecks.length > 0) {
        const failedList = failedChecks.map(([key]) => key).join(', ');
        setErrorMessage(`System Requirements Not Met: ${failedList}. Check diagnostics below for details.`);
        console.warn('ðŸ¤– Failed checks:', failedChecks);
        return;
      }
      
      console.log('âœ… System requirements: OK');

      // Step 2: Check WebLLM service
      console.log('ðŸ¤– Step 2: Checking WebLLM service...');
      const { WebLLMService } = await import('../../lib/webllm-service');
      const isSupported = WebLLMService.isSupported();
      console.log('ðŸ¤– WebLLM support:', isSupported);
      
      if (!isSupported) {
        setErrorMessage('WebLLM service not supported. WebGPU may not be available.');
        return;
      }
      
      console.log('âœ… WebLLM service: OK');

      // Step 3: Get model info
      console.log('ðŸ¤– Step 3: Getting model info...');
      const modelInfo = WebLLMService.getModelInfo();
      console.log('ðŸ¤– Model info:', modelInfo);
      console.log('âœ… Model info: OK');

      // Step 4: Test with a small sample
      console.log('ðŸ¤– Step 4: Testing with sample text...');
      const sampleText = "This is a test transcript for AI summarization. It contains some sample content to verify that the AI service is working correctly.";
      
      const result = await WebLLMService.summarizeTranscript(sampleText, {
        style: 'bullet',
        includeKeyPoints: true
      });
      
      console.log('ðŸ¤– Sample result:', result);
      console.log('âœ… AI summarization: OK');
      
      setErrorMessage('AI Diagnostics: All tests passed! AI summarization should work.');
      
    } catch (error) {
      console.error('ðŸ¤– AI diagnostics failed:', error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      
      // Provide specific error guidance
      if (errorMessage.includes('WebGPU')) {
        setErrorMessage('WebGPU Error: Enable WebGPU in chrome://flags/ or update your browser.');
      } else if (errorMessage.includes('memory')) {
        setErrorMessage('Memory Error: Close other tabs and try again. AI model requires ~2.4GB RAM.');
      } else if (errorMessage.includes('network')) {
        setErrorMessage('Network Error: Check your internet connection. AI model needs to download ~2.4GB.');
      } else {
        setErrorMessage(`AI Diagnostics Failed: ${errorMessage}`);
      }
    }
  };

  // Load AI summaries
  const loadAiSummaries = async () => {
    setIsLoadingSummaries(true);
    try {
      const summaries = await AISummaryStorage.getAllSummaries();
      setAiSummaries(summaries);
    } catch (error) {
      console.error('Failed to load AI summaries:', error);
    } finally {
      setIsLoadingSummaries(false);
    }
  };

  // Extract transcript and summarize in one go (for AI tab)
  const handleExtractAndSummarize = async () => {
    console.log('ðŸ¤– handleExtractAndSummarize called');
    setIsSummarizing(true);
    setErrorMessage('');
    setSummaryResult(null);
    setExtractionStatus('extracting');

    try {
      // First extract the transcript
      console.log('ðŸŽ¯ Extracting transcript for AI summarization...');
      const extractResponse = await ExtensionService.collectCurrentTranscript();
      console.log('ðŸŽ¯ Extract response:', extractResponse);
      
      if (!extractResponse.success || !extractResponse.data) {
        throw new Error(extractResponse.error || 'Failed to extract transcript');
      }

      const transcriptData = extractResponse.data;
      const transcript = typeof transcriptData === 'string' ? transcriptData : transcriptData.transcript;
      console.log('ðŸŽ¯ Transcript extracted, length:', transcript.length);
      
      if (!transcript || transcript.trim().length === 0) {
        throw new Error('Transcript is empty or invalid');
      }
      
      setExtractedTranscript(transcript);
      setExtractionStatus('success');

      // Check WebLLM support before attempting summarization
      console.log('ðŸ¤– Checking WebLLM support before summarization...');
      try {
        const { WebLLMService } = await import('../../lib/webllm-service');
        const isSupported = WebLLMService.isSupported();
        console.log('ðŸ¤– WebLLM support check result:', isSupported);
        
        if (!isSupported) {
          throw new Error('AI summarization is not supported in this browser. WebGPU is required. Please use Chrome/Edge with WebGPU enabled.');
        }
      } catch (importError) {
        console.error('ðŸ¤– Failed to import WebLLM service:', importError);
        throw new Error('Failed to load AI summarization service. Please refresh and try again.');
      }

      // Then summarize it
      console.log('ðŸ¤– Summarizing transcript with AI...');
      const summaryResponse = await ExtensionService.summarizeTranscript(transcript, summaryOptions);
      console.log('ðŸ¤– Summary response:', summaryResponse);
      
      if (summaryResponse.success && summaryResponse.data) {
        const summaryData = summaryResponse.data;
        console.log('ðŸ¤– Setting summary result:', summaryData);
        setSummaryResult(summaryData);

        // Save the AI summary with video information
        const aiSummary: AISummary = {
          id: `summary_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          videoTitle: currentVideo?.title || 'Unknown Video',
          videoUrl: window.location.href,
          transcript: transcript,
          summary: summaryData.summary,
          keyPoints: summaryData.keyPoints,
          summaryOptions: summaryOptions,
          timestamp: Date.now(),
          processingTime: summaryData.processingTime,
          modelUsed: summaryData.modelUsed
        };

        await AISummaryStorage.saveSummary(aiSummary);
        await loadAiSummaries(); // Reload the list
        
        console.log('ðŸ¤– Transcript extracted and summarized successfully:', summaryData);
      } else {
        console.log('ðŸ¤– Summary failed:', summaryResponse.error);
        throw new Error(summaryResponse.error || 'Failed to summarize transcript');
      }
    } catch (error) {
      console.error('ðŸ¤– Error during extraction/summarization:', error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      setErrorMessage(`AI Summarization Error: ${errorMessage}`);
      setExtractionStatus('error');
    } finally {
      setIsSummarizing(false);
    }
  };

  // Summarize existing transcript (for when transcript is already extracted)
  const handleSummarizeExistingTranscript = async () => {
    if (!extractedTranscript || extractedTranscript.trim().length === 0) {
      setErrorMessage('No transcript available to summarize');
      return;
    }

    console.log('ðŸ¤– handleSummarizeExistingTranscript called');
    setIsSummarizing(true);
    setErrorMessage('');
    setSummaryResult(null);

    try {
      // Check WebLLM support before attempting summarization
      console.log('ðŸ¤– Checking WebLLM support before summarization...');
      try {
        const { WebLLMService } = await import('../../lib/webllm-service');
        const isSupported = WebLLMService.isSupported();
        console.log('ðŸ¤– WebLLM support check result:', isSupported);
        
        if (!isSupported) {
          throw new Error('AI summarization is not supported in this browser. WebGPU is required. Please use Chrome/Edge with WebGPU enabled.');
        }
      } catch (importError) {
        console.error('ðŸ¤– Failed to import WebLLM service:', importError);
        throw new Error('Failed to load AI summarization service. Please refresh and try again.');
      }

      console.log('ðŸ¤– Summarizing existing transcript with AI...');
      const response = await ExtensionService.summarizeTranscript(extractedTranscript, summaryOptions);
      console.log('ðŸ¤– Summary response:', response);
      
      if (response.success && response.data) {
        const summaryData = response.data;
        console.log('ðŸ¤– Setting summary result:', summaryData);
        setSummaryResult(summaryData);

        // Save the AI summary
        const aiSummary: AISummary = {
          id: `summary_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          videoTitle: currentVideo?.title || 'Unknown Video',
          videoUrl: window.location.href,
          transcript: extractedTranscript,
          summary: summaryData.summary,
          keyPoints: summaryData.keyPoints,
          summaryOptions: summaryOptions,
          timestamp: Date.now(),
          processingTime: summaryData.processingTime,
          modelUsed: summaryData.modelUsed
        };

        await AISummaryStorage.saveSummary(aiSummary);
        await loadAiSummaries(); // Reload the list
        
        console.log('ðŸ¤– Transcript summarized successfully:', summaryData);
      } else {
        console.log('ðŸ¤– Summary failed:', response.error);
        setErrorMessage(`AI Summarization Error: ${response.error || 'Failed to summarize transcript'}`);
      }
    } catch (error) {
      console.error('ðŸ¤– Error during summarization:', error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      setErrorMessage(`AI Summarization Error: ${errorMessage}`);
    } finally {
      setIsSummarizing(false);
    }
  };

  // Export batch transcripts
  const handleExportBatch = async () => {
    if (clipboardEntries === 0) return;
    
    setIsExporting(true);
    setErrorMessage('');
    
    try {
      // Handle 'rag' format as 'markdown' for export
      const exportFormatForService = exportFormat === 'rag' ? 'markdown' : exportFormat;
      const response = await ExtensionService.exportBatchTranscripts(exportFormatForService as 'markdown' | 'txt' | 'json');
      
      if (response.success && response.data) {
        // Create and download the file
        const blob = new Blob([response.data], { 
          type: exportFormatForService === 'json' ? 'application/json' : 'text/plain' 
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `transcripts-export.${exportFormatForService === 'markdown' ? 'md' : exportFormatForService}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        console.log('ðŸ“ Batch export completed successfully');
      } else {
        setErrorMessage(response.error || 'Export failed');
      }
    } catch (error) {
      setErrorMessage('Export error: ' + (error instanceof Error ? error.message : String(error)));
    } finally {
      setIsExporting(false);
    }
  };

  // Export AI summaries
  const handleExportAiSummaries = async () => {
    if (aiSummaries.length === 0) return;
    
    setIsExporting(true);
    setErrorMessage('');
    
    try {
      // Handle 'rag' format as 'markdown' for export
      const exportFormatForService = exportFormat === 'rag' ? 'markdown' : exportFormat;
      const exportData = await AISummaryStorage.exportSummaries(exportFormatForService as 'markdown' | 'txt' | 'json');
      
      // Create and download the file
      const blob = new Blob([exportData], { 
        type: exportFormatForService === 'json' ? 'application/json' : 'text/plain' 
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `ai-summaries-export.${exportFormatForService === 'markdown' ? 'md' : exportFormatForService}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log('ðŸ¤– AI summaries export completed successfully');
    } catch (error) {
      setErrorMessage('Export error: ' + (error instanceof Error ? error.message : String(error)));
    } finally {
      setIsExporting(false);
    }
  };

  // Function to automatically clear all extension data
  const clearAllDataAutomatically = async () => {
    try {
      console.log('ðŸŽ¯ Auto-clearing all extension data...');
      
      // Clear storage data
      await StorageService.clearAllData();
      
      // Clear AI summaries
      await AISummaryStorage.clearAllSummaries();
      
      // Reset all state to defaults
      setBatchMode('next');
      setBatchProgress({});
      setBatchStats({ total: 0, completed: 0, failed: 0, skipped: 0 });
      setAiSummaries([]);
      setSummaryResult(null);
      setIsBatchCollecting(false);
      setCurrentProcessingLecture('');
      setCourseStructure(null);
      setCurrentVideo(null);
      setAvailability(null);
      setExtractedTranscript('');
      setExtractionStatus('idle');
      setErrorMessage('');
      setClipboardData('');
      setClipboardEntries(0);
      
      console.log('ðŸŽ¯ All extension data auto-cleared');
    } catch (error) {
      console.error('Failed to auto-clear extension data:', error);
    }
  };

  // Auto-save batch collection state when it changes (with debouncing)
  const debouncedSaveBatchState = useMemo(
    () => debounce((progress: any, stats: any, mode: any, collecting: boolean) => {
      if (progress && Object.keys(progress).length > 0) {
        StorageService.saveBatchState(progress, stats, mode, collecting);
      }
    }, 300),
    []
  );

  useEffect(() => {
    debouncedSaveBatchState(batchProgress, batchStats, batchMode, isBatchCollecting);
  }, [batchProgress, batchStats, batchMode, isBatchCollecting, debouncedSaveBatchState]);

  // Debug logging removed for production

  // Auto-save current processing lecture
  useEffect(() => {
    StorageService.saveState({ currentProcessingLecture });
  }, [currentProcessingLecture]);

  // Simple video title update and section detection
  useEffect(() => {
    if (currentVideo && currentVideo.title) {
      setCurrentProcessingLecture(currentVideo.title);
      
      // Check if we've moved to a new section
      const newSection = getCurrentSectionNumber();
      if (currentSection && currentSection !== newSection.toString() && isBatchCollecting) {
        // We've moved to a new section - increment the completed count
        setBatchStats(prev => {
          const updated = { ...prev, completed: prev.completed + 1 };
          return updated;
        });
        setProgressUpdateTrigger(prev => prev + 1);
      }
      setCurrentSection(newSection.toString());
    }
  }, [currentVideo, currentSection, isBatchCollecting, courseStructure]);

  // Auto-save course structure when it changes
  useEffect(() => {
    if (courseStructure) {
      StorageService.saveCourseStructure(courseStructure);
    }
  }, [courseStructure]);

  // Auto-save UI preferences when they change
  useEffect(() => {
    StorageService.saveState({
      exportFormat,
      exportTarget,
      includeTimestamps,
      extractedTranscript,
      extractionStatus
    });
  }, [exportFormat, exportTarget, includeTimestamps, extractedTranscript, extractionStatus]);

  // Load saved state from Chrome storage
  const loadSavedState = async () => {
    try {
      const savedState = await StorageService.loadState();
      
      // Restore batch collection state - but only if user was actively collecting
      // For new sessions, always start with batch collection inactive
      const wasActivelyCollecting = savedState.isBatchCollecting && savedState.batchStats.total > 0;
      
      if (wasActivelyCollecting) {
        // User was in middle of batch collection - restore their state
        setBatchMode(savedState.batchMode);
        setBatchProgress(savedState.batchProgress);
        setBatchStats(savedState.batchStats);
        setIsBatchCollecting(true);
        setCurrentProcessingLecture(savedState.currentProcessingLecture || '');
      } else {
        // New session or user wasn't collecting - start fresh
        setBatchMode('next');
        setBatchProgress({});
        setBatchStats({ total: 0, completed: 0, failed: 0, skipped: 0 });
        setIsBatchCollecting(false);
        setCurrentProcessingLecture('');
      }
      
      // Restore other UI state
      setExportFormat(savedState.exportFormat);
      setExportTarget(savedState.exportTarget);
      setIncludeTimestamps(savedState.includeTimestamps);
      
      // Validate extracted transcript - reset if invalid
      if (savedState.extractedTranscript && savedState.extractedTranscript.trim().length > 0) {
        setExtractedTranscript(savedState.extractedTranscript);
        setExtractionStatus(savedState.extractionStatus);
      } else {
        // Reset invalid extraction state
        setExtractedTranscript('');
        setExtractionStatus('idle');
      }
      
      // Restore course data if available
      if (savedState.courseStructure) {
        setCourseStructure(savedState.courseStructure);
      }
      if (savedState.currentVideo) {
        setCurrentVideo(savedState.currentVideo);
      }
      if (savedState.availability) {
        setAvailability(savedState.availability);
      }
      
      // State restored from storage
    } catch (error) {
      console.error('Failed to load saved state:', error);
    }
  };

  const checkPageAvailability = async () => {
    try {
      setExtractionStatus('extracting');
      setErrorMessage('');
      
      const response = await ExtensionService.checkAvailability();
      
      if (response.success && response.data) {
        setAvailability(response.data);
        setExtractionStatus('success');
        
        if (response.data.isCoursePage) {
          // Get current video info
          const videoInfo = await ExtensionService.getVideoInfo();
          if (videoInfo.success && videoInfo.data) {
            setCurrentVideo(videoInfo.data);
          } else {
            console.warn('Could not get video info:', videoInfo.error);
          }
          
          // Get course structure
          setIsCourseStructureLoading(true);
          const courseResponse = await ExtensionService.extractCourseStructure();
                if (courseResponse.success && courseResponse.data) {
              setCourseStructure(courseResponse.data);
          } else {
            console.warn('Could not get course structure:', courseResponse.error);
            setCourseStructure({ title: 'Unknown Course', sections: [] }); // Set an empty structure to indicate no data
          }
          setIsCourseStructureLoading(false);
        }
      } else {
        setErrorMessage(response.error || 'Could not detect page type');
        setExtractionStatus('error');
        // Set default values for development/testing
        setAvailability({
          platform: 'unknown',
          hasTranscript: false,
          isCoursePage: false
        });
      }
    } catch (error) {
      console.error('Error checking availability:', error);
      setErrorMessage('Extension communication failed');
      setExtractionStatus('error');
      // Set default values for development/testing
      setAvailability({
        platform: 'unknown',
        hasTranscript: false,
        isCoursePage: false
      });
    }
  };

  const handleExtractTranscript = async () => {
    console.log('ðŸŽ¯ handleExtractTranscript called');
    console.log('ðŸŽ¯ availability:', availability);
    console.log('ðŸŽ¯ hasTranscript:', availability?.hasTranscript);
    
    if (!availability?.hasTranscript) {
      console.log('ðŸŽ¯ No transcript available, aborting');
      setErrorMessage('No transcript available for this video');
      setExtractionStatus('error');
      return;
    }

    setIsExtracting(true);
    setExtractionStatus('extracting');
    setErrorMessage('');

    try {
      console.log('ðŸŽ¯ Calling ExtensionService.extractTranscript()...');
      const response = await ExtensionService.extractTranscript();
      console.log('ðŸŽ¯ ExtensionService.extractTranscript() response:', response);
      if (response.success && response.data) {
        setExtractedTranscript(response.data);
        setExtractionStatus('success');
        
        // Auto-export based on selected target
        await handleExport(response.data);
      } else {
        setErrorMessage(response.error || 'Failed to extract transcript');
        setExtractionStatus('error');
      }
    } catch (error) {
      setErrorMessage('Error extracting transcript');
      setExtractionStatus('error');
    } finally {
      setIsExtracting(false);
    }
  };

  // Test functions removed for production

  const handleExport = async (transcript: string) => {
    const formattedTranscript = ExtensionService.formatTranscript(
      transcript,
      exportFormat,
      includeTimestamps
    );

    try {
      switch (exportTarget) {
        case 'clipboard':
          const copied = await ExtensionService.copyToClipboard(formattedTranscript);
          if (!copied) {
            setErrorMessage('Failed to copy to clipboard');
          }
          break;

        case 'download':
          const filename = ExtensionService.generateFilename(
            currentVideo?.title || 'transcript',
            exportFormat
          );
          const mimeType = ExtensionService.getMimeType(exportFormat);
          ExtensionService.downloadFile(formattedTranscript, filename, mimeType);
          break;


      }
    } catch (error) {
      setErrorMessage('Export failed');
    }
  };

  // New function to append transcript to clipboard with storage management
  const appendToClipboard = async (transcript: string, lectureTitle: string) => {
    try {
      // Check if we're approaching the 5MB limit (roughly 5 million characters)
      const maxSize = 4.5 * 1024 * 1024; // 4.5MB to be safe
      
      if (clipboardData.length + transcript.length > maxSize) {
        setErrorMessage('Clipboard storage limit reached! Please export current data first.');
        return false;
      }

      // Format the transcript with title and separator
      const formattedTranscript = `\n\n=== ${lectureTitle} ===\n${transcript}\n`;
      
      // Append to clipboard data
      const newClipboardData = clipboardData + formattedTranscript;
      setClipboardData(newClipboardData);
      
      // Update clipboard entries count
      const newEntries = clipboardEntries + 1;
      setClipboardEntries(newEntries);
      
      // Save to Chrome storage
      await StorageService.saveClipboardData(newClipboardData, newEntries);
      
      // Copy to system clipboard
      await navigator.clipboard.writeText(newClipboardData);
      
      console.log('ðŸŽ¯ Appended transcript to clipboard. Total entries:', newEntries);
      return true;
    } catch (error) {
      console.error('Failed to append to clipboard:', error);
      setErrorMessage('Failed to append transcript to clipboard');
      return false;
    }
  };

  // Batch collection methods
  const handleBatchModeToggle = async () => {
    if (!isBatchCollecting) {
      // Starting batch collection
      console.log('ðŸŽ¯ Batch mode toggled ON - starting batch collection');
      await handleStartBatchCollection();
    } else {
      // Stopping batch collection
      console.log('ðŸŽ¯ Batch mode toggled OFF - stopping batch collection');
      setIsBatchCollecting(false);
      setBatchProgress({});
      setBatchStats({ total: 0, completed: 0, failed: 0, skipped: 0 });
      setBatchMode('next');
    }
  };

  const handleStartBatchCollection = async () => {
    console.log('ðŸŽ¯ Starting batch collection with course structure...');
    if (!availability?.hasTranscript) {
      console.log('ðŸŽ¯ No transcript available, aborting batch collection');
      return;
    }
    
    setIsBatchCollecting(true);
    setBatchProgress({});
    setErrorMessage('');
    
    // Use actual course structure to determine total sections
    try {
      // Get the actual course structure to determine total sections
      const courseResponse = await ExtensionService.extractCourseStructure();
      if (courseResponse.success && courseResponse.data && courseResponse.data.sections) {
        const totalSections = courseResponse.data.sections.length;
        console.log('ðŸŽ¯ Using actual course structure - total sections:', totalSections);
        
        // Reset all counters to ensure clean start
        setBatchStats({ total: totalSections, completed: 0, failed: 0, skipped: 0 });
        setBatchProgress({});
        console.log('ðŸŽ¯ Reset batch stats to zero');
        
        // Initialize current section
        const initialSection = getCurrentSectionNumber();
        setCurrentSection(initialSection.toString());
        console.log('ðŸŽ¯ Batch collection started with total sections:', totalSections, 'starting from section:', initialSection);
      } else {
        // Fallback to dynamic counting if course structure not available
        console.log('ðŸŽ¯ Course structure not available, using dynamic counting');
        setBatchStats({ total: 0, completed: 0, failed: 0, skipped: 0 });
        setBatchProgress({});
        
        // Initialize current section
        const initialSection = getCurrentSectionNumber();
        setCurrentSection(initialSection.toString());
        console.log('ðŸŽ¯ Batch collection started with dynamic counting, starting from section:', initialSection);
      }
    } catch (error) {
      console.log('ðŸŽ¯ Error setting up section counting, using dynamic counting:', error);
      setBatchStats({ total: 0, completed: 0, failed: 0, skipped: 0 });
      setBatchProgress({});
      
      // Initialize current section
      const initialSection = getCurrentSectionNumber();
      setCurrentSection(initialSection.toString());
      console.log('ðŸŽ¯ Batch collection started with error fallback, starting from section:', initialSection);
    }
  };

  const handleNextOrCollect = async () => {
    try {
      if (batchMode === 'next') {
        // Navigate to next lecture
        setIsNavigating(true);
        setCurrentProcessingLecture('Navigating...');
        
        const response = await ExtensionService.navigateToNextLecture();
        if (response.success) {
          setBatchMode('collect');
          setErrorMessage('');
          
          // Reduced refresh delay for faster response
          setTimeout(async () => {
            try {
              await checkPageAvailability();
              setIsNavigating(false);
              
              // Update video info
              const videoInfo = await ExtensionService.getVideoInfo();
              if (videoInfo.success && videoInfo.data) {
                setCurrentVideo(videoInfo.data);
                setCurrentProcessingLecture(videoInfo.data.title);
              }
              
              setErrorMessage('');
            } catch (error) {
              console.log('Failed to refresh page data:', error);
              setIsNavigating(false);
            }
          }, 800); // Reduced from 1500ms
        } else {
          setErrorMessage('Failed to navigate to next lecture');
          setIsNavigating(false);
          setCurrentProcessingLecture('');
        }
      } else {
        // Collect transcript from current lecture
        setCurrentProcessingLecture(currentVideo?.title || 'Collecting...');
        
        const response = await ExtensionService.collectCurrentTranscript();
        if (response.success && response.data) {
          const { lectureId, transcript } = response.data;
          
          // Update progress based on result
          if (transcript === 'NO_TRANSCRIPT_AVAILABLE') {
            setBatchProgress(prev => ({ ...prev, [lectureId]: 'skipped' as const }));
            setBatchStats(prev => ({ ...prev, skipped: prev.skipped + 1 }));
          } else if (transcript === 'EXTRACTION_FAILED') {
            setBatchProgress(prev => ({ ...prev, [lectureId]: 'failed' as const }));
            setBatchStats(prev => ({ ...prev, failed: prev.failed + 1 }));
          } else {
            setBatchProgress(prev => ({ ...prev, [lectureId]: 'completed' as const }));
            
            // Append transcript to clipboard
            const success = await appendToClipboard(transcript, currentVideo?.title || `Lecture ${lectureId}`);
            if (!success) {
              console.log('ðŸŽ¯ Failed to append transcript to clipboard');
            }
          }
          
          // Switch back to next mode
          setBatchMode('next');
          setErrorMessage('');
          setCurrentProcessingLecture('');
          setProgressUpdateTrigger(prev => prev + 1);
        } else {
          setErrorMessage('Failed to collect transcript');
          setCurrentProcessingLecture('');
        }
      }
    } catch (error) {
      setErrorMessage(`Failed to ${batchMode === 'next' ? 'navigate' : 'collect'}`);
      setCurrentProcessingLecture('');
    }
  };







  // Shared Extract Section Component
  const ExtractSection = () => <div className="space-y-6">
      {/* Current Video Info */}
      {currentVideo && (
        <div className="p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-800">
          <div className="flex items-center gap-2 mb-2">
            <Play className="w-4 h-4 text-blue-600 dark:text-blue-400" />
            <span className="text-sm font-medium text-blue-900 dark:text-blue-100">Current Video</span>
          </div>
          <h3 className="text-sm font-semibold text-blue-900 dark:text-blue-100 mb-1">
            {currentVideo.title}
          </h3>
          <p className="text-xs text-blue-700 dark:text-blue-300">
            Duration: {currentVideo.duration}
          </p>
        </div>
      )}

      {/* Availability Status */}
      {availability && (
        <div className={`p-4 rounded-lg border ${
          availability.hasTranscript 
            ? 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800' 
            : 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800'
        }`}>
          <div className="flex items-center gap-2">
            {availability.hasTranscript ? (
              <CheckCircle className="w-4 h-4 text-green-600 dark:text-green-400" />
            ) : (
              <AlertCircle className="w-4 h-4 text-yellow-600 dark:text-yellow-400" />
            )}
            <span className={`text-sm font-medium ${
              availability.hasTranscript 
                ? 'text-green-900 dark:text-green-100' 
                : 'text-yellow-900 dark:text-yellow-100'
            }`}>
              {availability.hasTranscript ? 'Transcript Available' : 'No Transcript Available'}
            </span>
          </div>
          <p className={`text-xs mt-1 ${
            availability.hasTranscript 
              ? 'text-green-700 dark:text-green-300' 
              : 'text-yellow-700 dark:text-yellow-300'
          }`}>
            Platform: {availability.platform}
          </p>
        </div>
      )}

      {/* Error Message */}
      {errorMessage && (
        <div className="p-4 bg-red-50 dark:bg-red-900/20 rounded-lg border border-red-200 dark:border-red-800">
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-red-600 dark:text-red-400" />
            <span className="text-sm font-medium text-red-900 dark:text-red-100">Error</span>
          </div>
          <p className="text-xs text-red-700 dark:text-red-300 mt-1">{errorMessage}</p>
        </div>
      )}

      {/* Batch Collection Toggle */}
      <div className={`p-4 rounded-lg border transition-all duration-200 ${
        isBatchCollecting 
          ? 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800' 
          : 'bg-gray-50 dark:bg-gray-800 border-gray-200 dark:border-gray-700'
      }`}>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Zap className={`w-4 h-4 ${isBatchCollecting ? 'text-blue-600 dark:text-blue-400' : 'text-gray-600 dark:text-gray-400'}`} />
            <div className="flex items-center gap-2">
              <span className={`text-sm font-medium ${isBatchCollecting ? 'text-blue-900 dark:text-blue-100' : 'text-gray-900 dark:text-gray-100'}`}>
                Batch Collection Mode
              </span>
              {isBatchCollecting && (
                <span className="text-xs bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 px-2 py-1 rounded-full font-medium">
                  ACTIVE
                </span>
              )}
            </div>
          </div>
          <label className="relative inline-flex items-center cursor-pointer">
            <input
              type="checkbox"
              checked={isBatchCollecting}
              onChange={handleBatchModeToggle}
              className="sr-only peer"
            />
            <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
          </label>
        </div>
        <p className={`text-xs mt-2 ${isBatchCollecting ? 'text-blue-700 dark:text-blue-300' : 'text-gray-600 dark:text-gray-400'}`}>
          {isBatchCollecting ? 'Batch collection is active - use Next/Collect buttons below' : 'Collect transcripts from multiple lectures automatically'}
        </p>
      </div>

      {/* Batch Collection Controls */}
      {isBatchCollecting && (
        <div className="space-y-4">
          {/* Simple Progress Bar - Always show when batch collecting */}
          <div className="p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-800">
            <div className="flex justify-between items-center text-sm mb-3">
              <div className="flex items-center gap-2">
                <LogIcon className="w-4 h-4 text-blue-600 dark:text-blue-400" />
                <span className="text-blue-900 dark:text-blue-100 font-medium">Batch Collection Active</span>
              </div>
              <span className="text-blue-700 dark:text-blue-300">
                {batchStats.total > 0 ? `${batchStats.completed}/${batchStats.total} sections` : `${batchStats.completed} sections processed`}
              </span>
            </div>
            
            {/* Simple Progress Bar */}
            <div className="mb-3">
              <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-3">
                <div 
                  className="bg-gradient-to-r from-blue-500 to-green-500 h-3 rounded-full transition-all duration-300 ease-out"
                  style={{ 
                    width: `${Math.min(progressPercentage, 100)}%` 
                  }}
                ></div>
              </div>
              <div className="flex justify-between text-xs text-gray-600 dark:text-gray-400 mt-1">
                <span>0%</span>
                <span className="font-medium">
                  {Math.round(progressPercentage)}%
                </span>
                <span>100%</span>
              </div>
            </div>

            {/* Current Status */}
            <div className="text-xs text-gray-600 dark:text-gray-400">
              {currentProcessingLecture ? (
                <div className="flex items-center gap-2">
                  <div className="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
                  <span>Processing: {currentProcessingLecture}</span>
                </div>
              ) : (
                <div className="flex items-center gap-2">
                  <div className="w-2 h-2 bg-green-500 rounded-full"></div>
                  <span>Ready to process next section</span>
                </div>
              )}
            </div>
          </div>

          {/* Status Breakdown - Only show when we have stats */}
          {batchStats.total > 0 && (
            <div className="flex justify-between items-center text-xs">
              <div className="flex gap-3">
                <span className="flex items-center gap-1 text-green-600 dark:text-green-400">
                  <CheckCircle className="w-3 h-3" />
                  {batchStats.completed} completed
                </span>
                <span className="flex items-center gap-1 text-blue-600 dark:text-blue-400">
                  <Clipboard className="w-3 h-3" />
                  {clipboardEntries} in clipboard
                </span>
                {batchStats.failed > 0 && (
                  <span className="flex items-center gap-1 text-red-600 dark:text-red-400">
                    <AlertCircle className="w-3 h-3" />
                    {batchStats.failed} failed
                  </span>
                )}
                {batchStats.skipped > 0 && (
                  <span className="flex items-center gap-1 text-yellow-600 dark:text-yellow-400">
                    <Clock className="w-3 h-3" />
                    {batchStats.skipped} skipped
                  </span>
                )}
              </div>
              <div className="flex items-center gap-1 text-gray-600 dark:text-gray-400">
                <LogIcon className="w-3 h-3" />
                <span>Log</span>
              </div>
            </div>
          )}

          {/* Batch Action Buttons */}
          <div className="flex gap-2">
            <button
              onClick={handleNextOrCollect}
              disabled={isNavigating}
              className={`w-full py-3 px-4 text-white rounded-lg text-sm font-medium transition-colors ${
                batchMode === 'next' 
                  ? 'bg-blue-600 hover:bg-blue-700' 
                  : 'bg-green-600 hover:bg-green-700'
              } ${isNavigating ? 'opacity-50 cursor-not-allowed' : ''}`}
            >
              {isNavigating ? (
                <div className="flex items-center justify-center gap-2">
                  <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                  <span>Navigating...</span>
                </div>
              ) : (
                <span>{batchMode === 'next' ? 'âž¡ Next Section' : 'ðŸ“ Collect Transcript'}</span>
              )}
            </button>
          </div>

          {/* Clipboard Management Buttons */}
          {clipboardEntries > 0 && (
            <div className="flex gap-2">
              <button
                onClick={async () => {
                  try {
                    const blob = new Blob([clipboardData], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `batch-transcripts-${Date.now()}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    setErrorMessage('Batch transcripts downloaded!');
                  } catch (error) {
                    setErrorMessage('Failed to download batch transcripts');
                  }
                }}
                className="flex-1 py-2 px-3 bg-purple-600 hover:bg-purple-700 text-white rounded-lg text-sm font-medium transition-colors flex items-center justify-center gap-2"
              >
                <LogIcon className="w-4 h-4" />
                Export All ({clipboardEntries})
              </button>
              <button
                onClick={async () => {
                  try {
                    await StorageService.clearClipboardData();
                    setClipboardData('');
                    setClipboardEntries(0);
                    setErrorMessage('Clipboard data cleared!');
                  } catch (error) {
                    setErrorMessage('Failed to clear clipboard data');
                  }
                }}
                className="py-2 px-3 bg-red-600 hover:bg-red-700 text-white rounded-lg text-sm font-medium transition-colors"
              >
                ðŸ—‘ï¸ Clear
              </button>
            </div>
          )}



        </div>
      )}

      {/* Extract Button */}
      <button 
        onClick={handleExtractTranscript} 
        disabled={isExtracting || !availability?.hasTranscript} 
        className={`w-full py-4 px-6 rounded-xl text-white font-medium transition-all duration-200 ${
          isExtracting || !availability?.hasTranscript 
            ? 'bg-gray-400 cursor-not-allowed' 
            : 'bg-[#4CAF50] hover:bg-[#45a049] shadow-lg hover:shadow-xl'
        }`}
      >
        {isExtracting ? (
          <div className="flex items-center justify-center gap-2">
          <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
          <span>Extracting...</span>
          </div>
        ) : (
          <div className="flex items-center justify-center gap-2">
                       <LogIcon className="w-6 h-6" />
            <span>Extract Transcript</span>
          </div>
        )}
      </button>

      {/* Course Structure */}
      <div className="p-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
        <div className="flex items-center gap-2 mb-3">
                      <LogIcon className="w-4 h-4 text-gray-600 dark:text-gray-400" />
          <span className="text-sm font-medium text-gray-900 dark:text-gray-100">Course Structure</span>
        </div>
        {isCourseStructureLoading ? (
          <div className="flex items-center justify-center p-4">
            <div className="w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full animate-spin mr-2"></div>
            <span className="text-sm text-gray-600 dark:text-gray-400">Loading course structure...</span>
          </div>
        ) : courseStructure && courseStructure.sections && courseStructure.sections.length > 0 ? (
          <div className="max-h-32 overflow-y-auto space-y-2">
            {courseStructure.sections?.slice(0, 5).map((section: any, index: number) => (
              <div key={index} className="text-xs">
                <div className="font-medium text-gray-700 dark:text-gray-300 mb-1">
                  {section.title} ({section.lectures?.length || 0} videos)
                </div>
                {section.lectures?.slice(0, 2).map((lecture: any, lIndex: number) => (
                  <div key={lIndex} className="text-gray-500 dark:text-gray-500 ml-2 mb-1">
                    â€¢ {lecture.title}
                  </div>
                ))}
                {section.lectures?.length > 2 && (
                  <div className="text-gray-400 dark:text-gray-600 ml-2 text-xs">
                    ... and {section.lectures.length - 2} more
                  </div>
                )}
              </div>
            ))}
            {courseStructure.sections?.length > 5 && (
              <div className="text-xs text-gray-500 dark:text-gray-400 text-center pt-2 border-t border-gray-200 dark:border-gray-700">
                ... and {courseStructure.sections.length - 5} more sections
              </div>
            )}
          </div>
        ) : (
          <div className="text-center p-4">
            <span className="text-sm text-gray-500 dark:text-gray-400">No course structure found</span>
          </div>
        )}
      </div>

      {/* Success Message */}
      {extractionStatus === 'success' && extractedTranscript && (
        <div className="p-4 bg-green-50 dark:bg-green-900/20 rounded-lg border border-green-200 dark:border-green-800">
          <div className="flex items-center gap-2">
            <CheckCircle className="w-4 h-4 text-green-600 dark:text-green-400" />
            <span className="text-sm font-medium text-green-900 dark:text-green-100">Transcript Extracted Successfully!</span>
          </div>
          <p className="text-xs text-green-700 dark:text-green-300 mt-1">
            {extractedTranscript.split('\n\n').length} entries extracted
          </p>
        </div>
      )}
    </div>;

  // Tab Navigation Component
  const TabNavigation = () => (
    <div className="flex bg-gray-100 dark:bg-gray-800 rounded-lg p-1 mb-6">
      {/* Debug indicator - remove this later */}
      <div className="absolute top-0 right-0 bg-red-500 text-white text-xs px-1 rounded-bl">v3.0.3</div>
      <button
        onClick={() => setActiveTab('transcript')}
        className={`flex-1 px-4 py-2 rounded-md text-sm font-medium transition-all duration-200 ${
          activeTab === 'transcript'
            ? 'bg-white dark:bg-gray-700 text-blue-600 dark:text-blue-400 shadow-sm'
            : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'
        }`}
      >
        <div className="flex items-center justify-center gap-2">
          <FileText className="w-4 h-4" />
          <span>Transcript</span>
        </div>
      </button>
      
      <button
        onClick={() => {
          console.log('ðŸ¤– AI tab clicked!');
          setActiveTab('ai');
        }}
        className={`flex-1 px-4 py-2 rounded-md text-sm font-medium transition-all duration-200 ${
          activeTab === 'ai'
            ? 'bg-white dark:bg-gray-700 text-purple-600 dark:text-purple-400 shadow-sm'
            : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'
        }`}
        disabled={isWebLLMSupported === false}
      >
        <div className="flex items-center justify-center gap-2">
          <Brain className="w-4 h-4" />
          <span>AI Summary</span>
          {isWebLLMSupported === false && (
            <AlertCircle className="w-3 h-3 text-red-500" />
          )}
        </div>
      </button>
      
      <button
        onClick={() => setActiveTab('tracking')}
        className={`flex-1 px-4 py-2 rounded-md text-sm font-medium transition-all duration-200 ${
          activeTab === 'tracking'
            ? 'bg-white dark:bg-gray-700 text-green-600 dark:text-green-400 shadow-sm'
            : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'
        }`}
      >
        <div className="flex items-center justify-center gap-2">
          <Download className="w-4 h-4" />
          <span>Tracking</span>
        </div>
      </button>
    </div>
  );

  // AI Summarization Tab Component
  const AISummarizationTab = () => (
    <div className="space-y-6">
      {/* Test Button - Remove this later */}
      <button
        onClick={() => {
          console.log('ðŸ§ª TEST BUTTON CLICKED - Popup is working!');
          alert('Test button works! Popup is functioning correctly.');
        }}
        className="w-full py-2 px-4 bg-green-600 hover:bg-green-700 text-white rounded-lg text-sm font-medium"
      >
        ðŸ§ª TEST BUTTON - Click me first!
      </button>
      {/* WebLLM Support Status */}
      {isWebLLMSupported === null && (
        <div className="p-4 bg-yellow-50 dark:bg-yellow-900/20 rounded-lg border border-yellow-200 dark:border-yellow-800">
          <div className="flex items-center gap-2">
            <Loader2 className="w-4 h-4 text-yellow-600 dark:text-yellow-400 animate-spin" />
            <span className="text-sm font-medium text-yellow-900 dark:text-yellow-100">Checking AI support...</span>
          </div>
        </div>
      )}

      {isWebLLMSupported === false && (
        <div className="p-4 bg-red-50 dark:bg-red-900/20 rounded-lg border border-red-200 dark:border-red-800">
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-red-600 dark:text-red-400" />
            <span className="text-sm font-medium text-red-900 dark:text-red-100">AI Summarization Not Available</span>
          </div>
          <p className="text-xs text-red-700 dark:text-red-300 mt-1">
            WebGPU is required for AI features. Please use Chrome or Edge browser.
          </p>
          
          {/* Comprehensive Diagnostics Display */}
          {diagnosticsResult && (
            <div className="mt-4 space-y-3">
              <h4 className="text-xs font-semibold text-red-900 dark:text-red-100">System Diagnostics:</h4>
              
              {/* WebGPU Status */}
              <div className="flex items-center justify-between text-xs">
                <span className="text-red-700 dark:text-red-300">WebGPU:</span>
                <span className={`font-medium ${diagnosticsResult.webgpu.available ? 'text-green-600' : 'text-red-600'}`}>
                  {diagnosticsResult.webgpu.available ? 'âœ… Available' : 'âŒ Not Available'}
                </span>
              </div>
              
              {/* WebAssembly Status */}
              <div className="flex items-center justify-between text-xs">
                <span className="text-red-700 dark:text-red-300">WebAssembly:</span>
                <span className={`font-medium ${diagnosticsResult.webassembly.available ? 'text-green-600' : 'text-red-600'}`}>
                  {diagnosticsResult.webassembly.available ? 'âœ… Available' : 'âŒ Not Available'}
                </span>
              </div>
              
              {/* WebGL Status */}
              <div className="flex items-center justify-between text-xs">
                <span className="text-red-700 dark:text-red-300">WebGL 2.0:</span>
                <span className={`font-medium ${diagnosticsResult.webgl.version2 ? 'text-green-600' : 'text-red-600'}`}>
                  {diagnosticsResult.webgl.version2 ? 'âœ… Available' : 'âŒ Not Available'}
                </span>
              </div>
              
              {/* Memory Status */}
              <div className="flex items-center justify-between text-xs">
                <span className="text-red-700 dark:text-red-300">Memory:</span>
                <span className={`font-medium ${parseInt(diagnosticsResult.memory.deviceMemory) >= 4 ? 'text-green-600' : 'text-yellow-600'}`}>
                  {diagnosticsResult.memory.deviceMemory}GB {parseInt(diagnosticsResult.memory.deviceMemory) >= 4 ? 'âœ…' : 'âš ï¸'}
                </span>
              </div>
              
              {/* Browser Info */}
              <div className="text-xs text-red-700 dark:text-red-300">
                <div>Browser: {diagnosticsResult.browser.userAgent.includes('Chrome') ? 'Chrome' : diagnosticsResult.browser.userAgent.includes('Edge') ? 'Edge' : 'Other'}</div>
                <div>Platform: {diagnosticsResult.browser.platform}</div>
              </div>
              
              {/* Fix Instructions */}
              <div className="mt-3 p-2 bg-red-100 dark:bg-red-800/30 rounded text-xs text-red-800 dark:text-red-200">
                <div className="font-semibold mb-1">Quick Fix:</div>
                <div>1. Go to <code>chrome://flags/</code></div>
                <div>2. Enable "Unsafe WebGPU"</div>
                <div>3. Restart browser</div>
                <div>4. Try AI diagnostics again</div>
              </div>
            </div>
          )}
        </div>
      )}

      {/* Model Information */}
      {isWebLLMSupported === true && (
        <div className="p-4 bg-purple-50 dark:bg-purple-900/20 rounded-lg border border-purple-200 dark:border-purple-800">
          <div className="flex items-center gap-2 mb-2">
            <Brain className="w-4 h-4 text-purple-600 dark:text-purple-400" />
            <span className="text-sm font-medium text-purple-900 dark:text-purple-100">AI Model Ready</span>
          </div>
          <p className="text-xs text-purple-700 dark:text-purple-300 mb-3">
            Using Phi-3 Mini (~2.4GB) - Small, efficient model for summarization
          </p>
          
          {/* System Status (when AI is working) */}
          {diagnosticsResult && (
            <div className="space-y-2">
              <div className="flex items-center justify-between text-xs">
                <span className="text-purple-700 dark:text-purple-300">WebGPU:</span>
                <span className="text-green-600 font-medium">âœ… Ready</span>
              </div>
              <div className="flex items-center justify-between text-xs">
                <span className="text-purple-700 dark:text-purple-300">Memory:</span>
                <span className="text-green-600 font-medium">{diagnosticsResult.memory.deviceMemory}GB âœ…</span>
              </div>
              <div className="flex items-center justify-between text-xs">
                <span className="text-purple-700 dark:text-purple-300">Browser:</span>
                <span className="text-green-600 font-medium">
                  {diagnosticsResult.browser.userAgent.includes('Chrome') ? 'Chrome âœ…' : 
                   diagnosticsResult.browser.userAgent.includes('Edge') ? 'Edge âœ…' : 'Compatible âœ…'}
                </span>
              </div>
            </div>
          )}
        </div>
      )}

      {/* Current Video Info */}
      {currentVideo && (
        <div className="p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-800">
          <div className="flex items-center gap-2 mb-2">
            <Play className="w-4 h-4 text-blue-600 dark:text-blue-400" />
            <span className="text-sm font-medium text-blue-900 dark:text-blue-100">Current Video</span>
          </div>
          <h3 className="text-sm font-semibold text-blue-900 dark:text-blue-100 mb-1">
            {currentVideo.title}
          </h3>
          <p className="text-xs text-blue-700 dark:text-blue-300">
            Duration: {currentVideo.duration}
          </p>
        </div>
      )}

      {/* Transcript Status */}
      {extractionStatus === 'success' && extractedTranscript && (
        <div className="p-4 bg-green-50 dark:bg-green-900/20 rounded-lg border border-green-200 dark:border-green-800">
          <div className="flex items-center gap-2">
            <CheckCircle className="w-4 h-4 text-green-600 dark:text-green-400" />
            <span className="text-sm font-medium text-green-900 dark:text-green-100">Transcript Ready</span>
          </div>
          <p className="text-xs text-green-700 dark:text-green-300 mt-1">
            {extractedTranscript.split('\n\n').length} entries extracted
          </p>
        </div>
      )}

      {(!extractedTranscript || extractionStatus !== 'success') && (
        <div className="p-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-gray-500" />
            <span className="text-sm text-gray-700 dark:text-gray-300">No transcript available</span>
          </div>
          <p className="text-xs text-gray-600 dark:text-gray-400 mt-1">
            Click "Extract & Summarize" to get transcript and AI summary in one go
          </p>
        </div>
      )}

      {/* Summarization Options */}
      {isWebLLMSupported === true && (
        <div className="space-y-4">
          <h3 className="text-sm font-semibold text-gray-900 dark:text-white">Summarization Options</h3>
          
          {/* Style */}
          <div className="space-y-2">
            <label className="text-xs font-medium text-gray-700 dark:text-gray-300">Summary Style</label>
            <div className="grid grid-cols-3 gap-2">
              {[
                { value: 'bullet', label: 'Bullet Points' },
                { value: 'paragraph', label: 'Paragraph' },
                { value: 'detailed', label: 'Detailed' }
              ].map(style => (
                <button
                  key={style.value}
                  onClick={() => setSummaryOptions({...summaryOptions, style: style.value as any})}
                  className={`p-2 text-xs rounded-lg border transition-colors ${
                    summaryOptions.style === style.value
                      ? 'bg-blue-100 dark:bg-blue-900 border-blue-300 dark:border-blue-700 text-blue-700 dark:text-blue-300'
                      : 'bg-gray-50 dark:bg-gray-800 border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'
                  }`}
                >
                  {style.label}
                </button>
              ))}
            </div>
          </div>

          {/* Key Points Toggle */}
          <div className="flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
            <div className="flex items-center gap-2">
              <Brain className="w-4 h-4 text-gray-500" />
              <span className="text-sm font-medium text-gray-700 dark:text-gray-300">Include Key Points</span>
            </div>
            <button
              onClick={() => setSummaryOptions({...summaryOptions, includeKeyPoints: !summaryOptions.includeKeyPoints})}
              className={`relative inline-flex h-5 w-9 items-center rounded-full transition-colors ${
                summaryOptions.includeKeyPoints ? 'bg-blue-600' : 'bg-gray-300 dark:bg-gray-600'
              }`}
            >
              <span
                className={`inline-block h-3 w-3 transform rounded-full bg-white transition-transform ${
                  summaryOptions.includeKeyPoints ? 'translate-x-5' : 'translate-x-1'
                }`}
              />
            </button>
          </div>
        </div>
      )}

      {/* Action Buttons */}
      {(() => {
        console.log('ðŸ¤– Button visibility check - isWebLLMSupported:', isWebLLMSupported);
        return (isWebLLMSupported === true || isWebLLMSupported === null);
      })() && (
        <div className="space-y-3">
          {/* Extract & Summarize Button (Primary) */}
          {console.log('ðŸ¤– Rendering Extract & Summarize button')}
          <button
            onClick={() => {
              console.log('ðŸ¤– Extract & Summarize button clicked!');
              handleExtractAndSummarize();
            }}
            disabled={isSummarizing || isExtracting}
            className={`w-full py-3 px-4 rounded-lg font-medium transition-all duration-200 ${
              isSummarizing || isExtracting
                ? 'bg-gray-400 cursor-not-allowed text-white'
                : 'bg-purple-600 hover:bg-purple-700 text-white shadow-lg hover:shadow-xl'
            }`}
          >
            {isSummarizing || isExtracting ? (
              <div className="flex items-center justify-center gap-2">
                <Loader2 className="w-4 h-4 animate-spin" />
                <span>{isExtracting ? 'Extracting...' : 'Summarizing...'}</span>
              </div>
            ) : (
              <div className="flex items-center justify-center gap-2">
                <Brain className="w-4 h-4" />
                <span>Extract & Summarize</span>
              </div>
            )}
          </button>

          {/* Summarize Existing Button (Secondary) */}
          {extractedTranscript && extractionStatus === 'success' && (
            <button
              onClick={handleSummarizeExistingTranscript}
              disabled={isSummarizing}
              className={`w-full py-2 px-4 rounded-lg font-medium transition-all duration-200 ${
                isSummarizing
                  ? 'bg-gray-400 cursor-not-allowed text-white'
                  : 'bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300'
              }`}
            >
              <div className="flex items-center justify-center gap-2">
                <Brain className="w-4 h-4" />
                <span>Re-summarize with New Options</span>
              </div>
            </button>
          )}

          {/* Diagnostic Button */}
          <button
            onClick={() => {
              console.log('ðŸ¤– AI Diagnostics button clicked!');
              runAIDiagnostics();
            }}
            className="w-full py-2 px-4 bg-orange-100 dark:bg-orange-900/20 hover:bg-orange-200 dark:hover:bg-orange-900/30 text-orange-700 dark:text-orange-300 rounded-lg text-sm font-medium transition-colors"
          >
            <div className="flex items-center justify-center gap-2">
              <AlertCircle className="w-4 h-4" />
              <span>Run AI Diagnostics</span>
            </div>
          </button>
        </div>
      )}

      {/* Summary Result */}
      {summaryResult && (
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <h3 className="text-sm font-semibold text-gray-900 dark:text-white">AI Summary</h3>
            <div className="flex items-center gap-4 text-xs text-gray-500 dark:text-gray-400">
              <span>{summaryResult.wordCount} words</span>
              <span>{summaryResult.processingTime}ms</span>
            </div>
          </div>
          
          <div className="p-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
            <div className="text-sm text-gray-900 dark:text-gray-100 whitespace-pre-wrap">
              {summaryResult.summary}
            </div>
          </div>

          {summaryResult.keyPoints && summaryResult.keyPoints.length > 0 && (
            <div className="space-y-2">
              <h4 className="text-xs font-semibold text-gray-900 dark:text-white">Key Points</h4>
              <div className="space-y-1">
                {summaryResult.keyPoints.map((point, index) => (
                  <div key={index} className="flex items-start gap-2 p-2 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                    <span className="text-xs font-medium text-blue-600 dark:text-blue-400 mt-0.5">{index + 1}.</span>
                    <span className="text-xs text-blue-900 dark:text-blue-100">{point}</span>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Copy Summary Button */}
          <button
            onClick={() => navigator.clipboard.writeText(summaryResult.summary)}
            className="w-full py-2 px-4 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 rounded-lg text-sm font-medium transition-colors"
          >
            <div className="flex items-center justify-center gap-2">
              <Clipboard className="w-4 h-4" />
              <span>Copy Summary</span>
            </div>
          </button>
        </div>
      )}
    </div>
  );

  // AI Summary Tracking Tab Component
  const AISummaryTrackingTab = () => (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h3 className="text-sm font-semibold text-gray-900 dark:text-white">AI Summary Tracking</h3>
        {aiSummaries.length > 0 && (
          <span className="text-xs text-gray-500 dark:text-gray-400">{aiSummaries.length} summaries</span>
        )}
      </div>
      
      {/* Loading State */}
      {isLoadingSummaries && (
        <div className="flex items-center justify-center p-4">
          <Loader2 className="w-4 h-4 animate-spin text-gray-500 mr-2" />
          <span className="text-sm text-gray-600 dark:text-gray-400">Loading AI summaries...</span>
        </div>
      )}

      {/* No Summaries */}
      {!isLoadingSummaries && aiSummaries.length === 0 && (
        <div className="p-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 text-center">
          <Brain className="w-8 h-8 text-gray-400 mx-auto mb-2" />
          <p className="text-sm text-gray-600 dark:text-gray-400">No AI summaries yet</p>
          <p className="text-xs text-gray-500 dark:text-gray-500 mt-1">
            Go to the AI Summary tab to create your first summary
          </p>
        </div>
      )}

      {/* AI Summaries List */}
      {!isLoadingSummaries && aiSummaries.length > 0 && (
        <div className="space-y-4">
          {aiSummaries.map((summary, index) => (
            <div key={summary.id} className="p-4 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
              <div className="flex items-start justify-between mb-3">
                <div className="flex-1">
                  <h4 className="text-sm font-semibold text-gray-900 dark:text-white mb-1">
                    {summary.videoTitle}
                  </h4>
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    {new Date(summary.timestamp).toLocaleString()}
                  </p>
                </div>
                <button
                  onClick={() => AISummaryStorage.deleteSummary(summary.id).then(() => loadAiSummaries())}
                  className="text-red-500 hover:text-red-700 text-xs"
                >
                  Delete
                </button>
              </div>
              
              <div className="space-y-2">
                <div className="text-xs text-gray-600 dark:text-gray-400">
                  <span className="font-medium">Summary:</span> {summary.summary.substring(0, 100)}
                  {summary.summary.length > 100 && '...'}
                </div>
                
                <div className="flex items-center gap-4 text-xs text-gray-500 dark:text-gray-400">
                  <span>{summary.summaryOptions.style} style</span>
                  <span>150 words</span>
                  <span>{summary.processingTime}ms</span>
                  {summary.keyPoints && summary.keyPoints.length > 0 && (
                    <span>{summary.keyPoints.length} key points</span>
                  )}
                </div>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Export Options */}
      {aiSummaries.length > 0 && (
        <div className="space-y-4">
          <h4 className="text-xs font-semibold text-gray-900 dark:text-white">Export AI Summaries</h4>
          
          {/* Export Format */}
          <div className="space-y-2">
            <label className="text-xs font-medium text-gray-700 dark:text-gray-300">Format</label>
            <div className="grid grid-cols-3 gap-2">
              {['markdown', 'txt', 'json'].map(format => (
                <button
                  key={format}
                  onClick={() => setExportFormat(format as any)}
                  className={`p-2 text-xs rounded-lg border transition-colors ${
                    exportFormat === format
                      ? 'bg-blue-100 dark:bg-blue-900 border-blue-300 dark:border-blue-700 text-blue-700 dark:text-blue-300'
                      : 'bg-gray-50 dark:bg-gray-800 border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'
                  }`}
                >
                  {format.toUpperCase()}
                </button>
              ))}
            </div>
          </div>

          {/* Export Button */}
          <button
            onClick={handleExportAiSummaries}
            disabled={aiSummaries.length === 0 || isExporting}
            className={`w-full py-3 px-4 rounded-lg font-medium transition-all duration-200 ${
              aiSummaries.length === 0 || isExporting
                ? 'bg-gray-400 cursor-not-allowed text-white'
                : 'bg-green-600 hover:bg-green-700 text-white shadow-lg hover:shadow-xl'
            }`}
          >
            {isExporting ? (
              <div className="flex items-center justify-center gap-2">
                <Loader2 className="w-4 h-4 animate-spin" />
                <span>Exporting...</span>
              </div>
            ) : (
              <div className="flex items-center justify-center gap-2">
                <Download className="w-4 h-4" />
                <span>Export {aiSummaries.length} AI Summaries</span>
              </div>
            )}
          </button>
        </div>
      )}
    </div>
  );

  // Shared Export Options Component
  const ExportOptionsSection = () => <div className="space-y-4">
      <h3 className="text-sm font-semibold text-gray-900 dark:text-white">
        <span>Export Options</span>
      </h3>
      
      {/* Export Format */}
      <div className="space-y-2">
        <label className="text-xs font-medium text-gray-700 dark:text-gray-300">
          <span>Format</span>
        </label>
        <div className="relative">
          <button onClick={() => setShowFormatDropdown(!showFormatDropdown)} className="w-full flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
            <span className="text-sm text-gray-700 dark:text-gray-300 capitalize">{exportFormat}</span>
            <ChevronDown className="w-4 h-4 text-gray-500" />
          </button>
          
                     {showFormatDropdown && <div className="absolute top-full mt-1 w-full bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg z-10">
               {['markdown', 'txt', 'json', 'rag'].map(format => <button key={format} onClick={() => {
             setExportFormat(format as 'markdown' | 'txt' | 'json' | 'rag');
             setShowFormatDropdown(false);
           }} className="w-full px-3 py-2 text-left text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 first:rounded-t-lg last:rounded-b-lg capitalize">
                   <span>{format === 'rag' ? 'RAG' : format}</span>
                 </button>)}
             </div>}
        </div>
      </div>

      {/* Include Timestamps Toggle - Hidden for now */}
      {/* <div className="flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
        <div className="flex items-center gap-2">
          <Clock className="w-4 h-4 text-gray-500" />
          <span className="text-sm font-medium text-gray-700 dark:text-gray-300">Include Timestamps</span>
        </div>
        <button onClick={() => setIncludeTimestamps(!includeTimestamps)} className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${includeTimestamps ? 'bg-[#4CAF50]' : 'bg-gray-300 dark:bg-gray-600'}`}>
          <span className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${includeTimestamps ? 'translate-x-6' : 'translate-x-1'}`} />
        </button>
      </div> */}


    </div>;


  return <div className="w-[400px] h-[600px] bg-white dark:bg-gray-900 flex flex-col shadow-2xl rounded-xl overflow-hidden border border-gray-200 dark:border-gray-800">
      {/* Header */}
      <header className="flex items-center justify-between p-4 bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-800">
                 <div className="flex items-center space-x-3">
                       <div className="p-1 bg-white rounded-lg shadow-sm border border-gray-200">
              <LogIcon className="w-12 h-12" />
            </div>
          <div>
            <h1 className="text-sm font-semibold text-gray-900 dark:text-white">
              <span>Transcript Extractor</span>
            </h1>
          </div>
        </div>
        
        <button onClick={handleThemeToggle} className="p-2 rounded-lg bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 transition-all duration-200 border border-gray-200 dark:border-gray-700" aria-label={isDarkMode ? 'Switch to light mode' : 'Switch to dark mode'}>
          {isDarkMode ? <Sun className="w-4 h-4 text-yellow-500" /> : <Moon className="w-4 h-4 text-gray-600" />}
        </button>
      </header>



      {/* Main Content */}
      <main className="flex-1 overflow-y-auto">
        <div className="p-6 space-y-6">
          {/* Tab Navigation */}
          <TabNavigation />
          
          {/* Tab Content */}
          {activeTab === 'transcript' && (
            <div className="space-y-6">
              <ExtractSection />
              <ExportOptionsSection />
            </div>
          )}
          
          {activeTab === 'ai' && (
            <AISummarizationTab />
          )}
          
          {activeTab === 'tracking' && (
            <AISummaryTrackingTab />
          )}
        </div>
      </main>

      {/* Footer */}
      <footer className="p-4 bg-gray-50 dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700">
        <div className="flex items-center justify-center gap-3 text-xs text-gray-500 dark:text-gray-400">
          <div className="flex items-center gap-1">
            <Lock className="w-3 h-3" />
            <span>Local-first</span>
          </div>
          <span>â€¢</span>
          <div className="flex items-center gap-1">
            <Github className="w-3 h-3" />
            <span>Open Source</span>
          </div>
          <span>â€¢</span>
          <span>MIT License</span>
        </div>
      </footer>
    </div>;
};